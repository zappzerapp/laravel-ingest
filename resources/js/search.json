[[{"l":"Introduction to Laravel Ingest","p":["Laravel Ingest revolutionizes the way Laravel applications import data. We end the chaos of custom, error-prone import scripts and provide an elegant, declarative, and robust framework for defining complex data import processes.","The system handles the \"dirty\" work—file processing, streaming, validation, background jobs, error reporting, and API provision—so you can focus on the business logic."]},{"l":"The Core Problem We Solve","p":["Importing data (CSV, Excel, etc.) is often a painful process: repetitive code, lack of robustness with large files, poor user experience, and inadequate error handling. Laravel Ingest solves this with a declarative, configuration-driven approach."]},{"l":"Key Features","p":["Limitless Scalability: By consistently utilizing streams and queues, there is no limit to file size. Whether 100 rows or 10 million, memory usage remains consistently low.","Fluent & Expressive API: Define imports in a readable and self-explanatory way using the IngestConfig class.","Source Agnostic: Import from file uploads, (S)FTP servers, URLs, or any Laravel filesystem disk ( s3, local). Easily extensible for other sources.","Robust Background Processing: Uses the Laravel Queue by default for maximum reliability.","Comprehensive Mapping & Validation: Transform data on-the-fly, resolve relationships, and use the validation rules of your Eloquent models.","Auto-generated API & CLI: Control and monitor imports via RESTful endpoints or the included Artisan commands.","\"Dry Runs\": Simulate an import to detect validation errors without writing a single database entry."]}],[{"l":"Custom Source Handlers","p":["While Laravel Ingest provides handlers for common sources like uploads, filesystems, and URLs, you may need to import data from a custom source, such as a proprietary API, an XML feed, or a different database. You can achieve this by creating your own source handler."]},{"l":"1. The SourceHandler Contract","p":["A source handler is any class that implements the LaravelIngest\\Contracts\\SourceHandler interface. This interface defines four methods:","read(): This is the core method. It must return a Generator that yields one row at a time as an associative array. Using a generator is crucial for keeping memory usage low with large data sets.","getTotalRows(): Should return the total number of rows that will be processed. This is used to update the progress display.","getProcessedFilePath(): If your handler creates a temporary file, this method should return its path so it can be stored on the IngestRun model for debugging.","cleanup(): This method is called after the import is finished (or has failed) to allow you to clean up any temporary resources, like deleting a temp file."]},{"l":"2. Example: An ArrayHandler","p":["Let's create a simple handler that processes a plain PHP array passed directly as a payload."]},{"l":"3. Registering the Handler","p":["To make your new handler available, you need to register it in the config/ingest.php file. You can do this by overriding an existing, unused handler or by modifying the code to use a custom key. For simplicity, we'll override the SFTP handler."]},{"l":"4. Using the Handler","p":["Now you can use SourceType::SFTP in your IngestConfig to invoke your ArrayHandler."]}],[{"l":"Working with Events","p":["Laravel Ingest fires a series of events throughout the import lifecycle, allowing you to easily hook into the process to add custom logic, notifications, or logging.","You can register listeners for these events in your EventServiceProvider."]},{"l":"LaravelIngest\\Events\\IngestRunStarted","p":["Fired as soon as an IngestRun model is created and the import process begins.","$ingestRun: The IngestRun Eloquent model."]},{"l":"LaravelIngest\\Events\\ChunkProcessed","p":["Fired by a background job after it finishes processing a chunk of rows.","$ingestRun: The IngestRun Eloquent model.","$results(array): An array with statistics for the processed chunk, e.g., ['processed' = 100, 'successful' = 98, 'failed' = 2]."]},{"l":"LaravelIngest\\Events\\RowProcessed","p":["Fired for every single row after it has been processed. This is a very powerful but potentially high-volume event.","$ingestRun: The IngestRun model.","$status(string): The result of the processing ('success' or 'failed').","$originalData(array): The raw data for the row from the source file.","$model(?Model): The created or updated Eloquent model instance on success, null on failure.","$errors(?array): An array of error details on failure, null on success."]},{"l":"LaravelIngest\\Events\\IngestRunCompleted","p":["Fired when the entire import batch successfully completes. This event is triggered from the then() callback of the Laravel Job Batch.","$ingestRun: The IngestRun Eloquent model, now with final statistics."]},{"l":"LaravelIngest\\Events\\IngestRunFailed","p":["Fired when the import process fails. This can happen if a job in the batch throws an exception that isn't caught, or if an error occurs before the batch is even dispatched (e.g., the source file is not found).","$ingestRun: The IngestRun Eloquent model.","$exception(?Throwable): The exception that caused the failure, if available."]}],[{"l":"Available Source Types","p":["Laravel Ingest is designed to be source-agnostic. You define the source of your data using the fromSource() method on your IngestConfig object. Here are the built-in source handlers and their required options."]},{"l":"SourceType::UPLOAD","p":["This is the most common source type for user-facing imports. It expects a file to be provided via an API request.","Payload: An instance of Illuminate\\Http\\UploadedFile.","Options: No options are required in the IngestConfig."]},{"l":"SourceType::FILESYSTEM","p":["This handler reads a file directly from one of your configured Laravel filesystem disks (e.g., local, s3). It's ideal for imports triggered by console commands or scheduled jobs.","Payload: The path to the file can be passed as a string payload to the IngestManager::start() method, which is what the ingest:run --file=... command does.","Options:","path(string): The default path to the file if no payload is provided.","disk(string, optional): Overrides the default disk for this specific import."]},{"l":"SourceType::URL","p":["This handler downloads a file from a public URL and processes it. The file is streamed to a temporary local file to keep memory usage low.","Payload: None. The URL is configured directly.","Options:","url(string): The full URL to the file to be downloaded."]},{"l":"SourceType::FTP & SourceType::SFTP","p":["These handlers use the RemoteDiskHandler to download a file from a remote server configured as a Laravel filesystem disk. This requires a corresponding disk configuration in config/filesystems.php.","Payload: None.","Options:","disk(string): The name of the FTP/SFTP disk configured in config/filesystems.php.","path(string): The path to the file on the remote server."]},{"l":"Example Filesystem Configuration","p":["First, configure your disk in config/filesystems.php:"]},{"l":"Example IngestConfig","p":["Then, use the configured disk in your importer:"]}],[{"l":"The IngestConfig Class","p":["The IngestConfig object is the heart of every importer. It provides a fluent, expressive API to define every aspect of the import process, from the data source to validation and data transformation.","All configuration is done within the getConfig() method of your IngestDefinition class."]},{"l":"Core Methods"},{"l":"for(string $modelClass)","p":["Initializes the configuration for a specific Eloquent model. This is always the first call."]},{"l":"fromSource(SourceType $sourceType, array $options = [])","p":["Defines the source of the data. See the Available Source Types page for details on each type and its required options."]},{"l":"Data Identification"},{"l":"keyedBy(string $sourceField)","p":["Sets the unique identifier column from your source file (e.g., SKU, email). This is crucial for handling duplicates."]},{"l":"onDuplicate(DuplicateStrategy $strategy)","p":["Defines what to do when a record with the same key already exists in the database.","DuplicateStrategy::UPDATE: Updates the existing record with the new data.","DuplicateStrategy::SKIP: (Default) Ignores the incoming row and leaves the existing record unchanged.","DuplicateStrategy::FAIL: Marks the incoming row as failed and reports a duplicate error."]},{"l":"Mapping & Transformation"},{"l":"map(string $sourceField, string $modelAttribute)","p":["Creates a direct mapping from a source column to a model attribute."]},{"l":"mapAndTransform(string $sourceField, string $modelAttribute, callable $transformer)","p":["Maps a source column and transforms its value using a closure before it's assigned to the model. The closure receives the value and the full original row data as arguments."]},{"l":"relate(string $sourceField, string $relationName, string $relatedModel, string $relatedKey = 'id')","p":["Resolves a BelongsTo relationship. It looks up the related model's ID and sets the foreign key on the primary model."]},{"l":"Validation"},{"l":"validate(array $rules)","p":["Applies Laravel validation rules to the incoming data before transformation."]},{"l":"validateWithModelRules()","p":["Merges rules from a static getRules() method on your target model. This is great for keeping validation logic centralized."]},{"l":"Process Control"},{"l":"setChunkSize(int $size)","p":["Defines how many rows are processed in a single background job. The default is 100."]},{"l":"setDisk(string $diskName)","p":["Specifies the Laravel Filesystem disk to use for UPLOAD or FILESYSTEM sources. Defaults to the disk set in config/ingest.php."]},{"l":"atomic()","p":["Wraps the processing of each chunk in a database transaction. If any row within a chunk fails, all changes from that chunk are rolled back. This ensures data integrity."]},{"l":"Callbacks / Hooks"},{"l":"beforeRow(callable $callback)","p":["Executes a closure just before a row is validated and processed. You can modify the data by reference."]},{"l":"afterRow(callable $callback)","p":["Executes a closure after a row has been successfully processed and persisted. The closure receives the saved model instance and the original row data."]}],[{"l":"Installation","p":["Getting started with Laravel Ingest is simple. Follow these steps to integrate the package into your project."]},{"l":"1. Require with Composer","p":["First, add the package to your project's dependencies using Composer:"]},{"l":"2. Publish Assets","p":["Next, publish the configuration file and database migrations. This will create config/ingest.php and the necessary migration files in database/migrations/.","You can choose to publish only the configuration or the migrations by using the tags ingest-config or ingest-migrations."]},{"l":"3. Run Migrations","p":["Run the database migrations to create the ingest_runs and ingest_rows tables. These tables are essential for tracking the status and results of your imports.","That's it! Laravel Ingest is now installed and ready to be configured."]}],[{"l":"Your First Importer","p":["Let's create a simple importer to understand the core concepts of Laravel Ingest. We will build an importer for a User model."]},{"l":"1. Define the Importer Class","p":["An importer is a simple PHP class that implements the IngestDefinition interface. This interface has a single method, getConfig(), which returns an IngestConfig object. This object declaratively defines the entire import process.","Create a new file at app/Ingest/UserImporter.php:","This configuration tells Laravel Ingest to:","Import data into the User model.","Expect a file UPLOAD as the source.","Use the email column to identify unique records.","If a user with the same email already exists, UPDATE their record.","Map the CSV column full_name to the name attribute on the model.","Map user_email to email.","Map is_admin to is_admin, transforming the value \"yes\" into a boolean.","Use validation rules defined on the User model."]},{"l":"2. Register the Importer","p":["To make your importer discoverable by the framework, you need to \"tag\" it in a service provider. The AppServiceProvider is a great place for this.","Laravel Ingest automatically generates a URL-friendly \"slug\" from the class name. UserImporter becomes user-importer."]},{"l":"3. Run the Import","p":["Your importer is now ready! You can trigger it via the built-in API or the command line. Prepare a CSV file named users.csv:"]},{"l":"Via API","p":["Send a multipart/form-data POST request to the auto-generated endpoint:"]},{"l":"Via CLI","p":["If your file is on a disk accessible by the application, you can use the Artisan command:","The import will be queued and processed in the background. You can now monitor its progress."]}],[{"l":"Monitoring, Cancellation, and Retries","p":["After starting an import, you can monitor its progress, cancel it if necessary, or retry any failed rows. These actions can be performed via Artisan commands or the API."]},{"l":"Monitoring Status","p":["Each import process creates an IngestRun record in the database. You can query this record to get detailed information about the status and progress of the import."]},{"l":"Via Artisan Command","p":["Use the ingest:status command with the run ID.","This will display a detailed summary, including status, progress counts, and a progress bar for running imports. If the run failed, it will also display the error message."]},{"l":"Via API","p":["Make a GET request to the show endpoint.","Endpoint: GET /api/v1/ingest/{ingestRun}","The response will be a JSON object containing the full IngestRun details, including a list of all processed rows if the run is configured to log them."]},{"l":"Cancelling an Ingest Run","p":["You can request to cancel a batch that is currently processing. This is useful if you start a large import by mistake.","Note: Cancellation sends a signal to the Laravel Queue batch. It may take a moment for currently processing jobs to finish before the batch is marked as cancelled."]},{"i":"via-artisan-command-1","l":"Via Artisan Command"},{"i":"via-api-1","l":"Via API","p":["Endpoint: POST /api/v1/ingest/{ingestRun}/cancel"]},{"l":"Retrying Failed Rows","p":["If an import completes with failed rows, you don't need to re-upload the entire file. You can create a new import run that consists only of the rows that failed in the original run."]},{"i":"via-artisan-command-2","l":"Via Artisan Command","p":["Use the ingest:retry command with the ID of the original failed run.","This will create a new IngestRun and queue the jobs. You will get a new run ID to monitor."]},{"i":"via-api-2","l":"Via API","p":["Endpoint: POST /api/v1/ingest/{ingestRun}/retry","The response will be the JSON representation of the new ingest run that has been created."]}],[{"l":"Running Imports","p":["Once an importer is defined and registered, you can start an import process in several ways, depending on your use case."]},{"l":"1. Via Artisan Command","p":["The ingest:run command is perfect for manual or scheduled imports where the source file is accessible on a local or configured filesystem disk."]},{"l":"Command Signature","p":["slug: The slug of the importer you want to run (e.g., user-importer).","--file: (Optional) The path to the source file. This is required for FILESYSTEM sources and will be passed as the payload.","--dry-run: (Optional) Simulates the entire import process—including validation and transformation—without saving any data to the database. This is extremely useful for testing a new file."]},{"l":"Example"},{"l":"2. Via API","p":["Laravel Ingest automatically registers API endpoints to trigger and manage imports. These are ideal for integrations or when providing a user interface for uploads."]},{"l":"File Uploads (UPLOAD source)","p":["To start an import that uses SourceType::UPLOAD, send a multipart/form-data POST request.","Endpoint: POST /api/v1/ingest/upload/{importerSlug}","Body: Must contain a file field with the uploaded file. You can also include an optional dry_run field set to 1 or true."]},{"l":"Triggering Other Sources (FTP, URL, etc.)","p":["For importers that don't require a file upload (like FTP or URL sources), you can trigger them with a simple POST request.","Endpoint: POST /api/v1/ingest/trigger/{importerSlug}"]},{"l":"3. Programmatically","p":["You can start an import directly from your application code by using the IngestManager. This is useful for complex workflows, scheduled jobs, or custom controllers."]}],[{"l":"API Reference","p":["Laravel Ingest exposes a RESTful API for managing and monitoring import processes. All endpoints are prefixed with /api/v1/ingest."]},{"l":"Authentication","p":["The API routes are wrapped in the api middleware group by default. You will typically need to provide an authentication token (e.g., Sanctum or Passport) in the Authorization header."]},{"l":"List Ingest Runs","p":["Retrieves a paginated list of all ingest runs, sorted by the most recent.","Endpoint: GET /","Success Response: 200 OK with a paginated JSON object of IngestRunResource objects."]},{"l":"Show Ingest Run Details","p":["Retrieves the details of a single ingest run, including its rows.","Endpoint: GET /{ingestRun}","URL Parameters:","ingestRun(integer, required): The ID of the ingest run.","Success Response: 200 OK with a single IngestRunResource object."]},{"l":"Upload File and Start Run","p":["Starts a new ingest run from a file upload.","Endpoint: POST /upload/{importerSlug}","URL Parameters:","importerSlug(string, required): The slug of the importer definition.","Body (multipart/form-data):","file(file, required): The data file to import (e.g., CSV, XLSX).","dry_run(boolean, optional): If 1 or true, performs a simulation without saving data.","Success Response: 202 Accepted with the newly created IngestRunResource."]},{"l":"Trigger Non-Upload Run","p":["Starts a new ingest run for a source that does not require a file upload (e.g., FTP, URL).","Endpoint: POST /trigger/{importerSlug}","URL Parameters:","importerSlug(string, required): The slug of the importer definition.","Success Response: 202 Accepted with the newly created IngestRunResource."]},{"l":"Cancel Ingest Run","p":["Sends a cancellation request to a running ingest batch.","Endpoint: POST /{ingestRun}/cancel","URL Parameters:","ingestRun(integer, required): The ID of the ingest run to cancel.","Success Response: 200 OK with {message: Cancellation request sent.}."]},{"l":"Retry Failed Ingest Run","p":["Creates a new ingest run containing only the failed rows from a previous run.","Endpoint: POST /{ingestRun}/retry","URL Parameters:","ingestRun(integer, required): The ID of the original run with failed rows.","Body (application/json, optional):","{dry_run: true}","Success Response: 202 Accepted with the newly created retry IngestRunResource.","Error Response: 400 Bad Request if the original run has no failed rows."]},{"l":"IngestRunResource Object","p":["The standard JSON representation for an ingest run."]}]]