[[{"l":"Introduction to Laravel Ingest","p":["Laravel Ingest revolutionizes the way Laravel applications import data. We end the chaos of custom, error-prone import scripts and provide an elegant, declarative, and robust framework for defining complex data import processes.","The system handles the \"dirty\" work—file processing, streaming, validation, background jobs, error reporting, and API provision—so you can focus on the business logic."]},{"l":"The Core Problem We Solve","p":["Importing data (CSV, Excel, etc.) is often a painful process: repetitive code, lack of robustness with large files, poor user experience, and inadequate error handling. Laravel Ingest solves this with a declarative, configuration-driven approach."]},{"l":"Key Features","p":["Limitless Scalability: By consistently utilizing streams and queues, there is no limit to file size. Whether 100 rows or 10 million, memory usage remains consistently low.","Fluent & Expressive API: Define imports in a readable and self-explanatory way using the IngestConfig class.","Source Agnostic: Import from file uploads, (S)FTP servers, URLs, or any Laravel filesystem disk ( s3, local). Easily extensible for other sources.","Robust Background Processing: Uses the Laravel Queue by default for maximum reliability.","Comprehensive Mapping & Validation: Transform data on-the-fly, resolve relationships, and use the validation rules of your Eloquent models.","Column Aliases: Support multiple header names for the same field (e.g., ['email', 'E-Mail', 'user_email']).","Dynamic Model Resolution: Route rows to different Eloquent models based on row data.","Auto-Create Relations: Automatically create missing related records during import.","Auto-generated API & CLI: Control and monitor imports via RESTful endpoints or the included Artisan commands.","\"Dry Runs\": Simulate an import to detect validation errors without writing a single database entry.","Error Analysis: Aggregated error summaries via dedicated API endpoint."]}],[{"l":"Installation","p":["Getting started with Laravel Ingest is simple. Follow these steps to integrate the package into your project."]},{"l":"1. Require with Composer","p":["First, add the package to your project's dependencies using Composer:"]},{"l":"2. Publish Assets","p":["Next, publish the configuration file and database migrations. This will create config/ingest.php and the necessary migration files in database/migrations/.","You can choose to publish only the configuration or the migrations by using the tags ingest-config or ingest-migrations."]},{"l":"3. Run Migrations","p":["Run the database migrations to create the ingest_runs and ingest_rows tables. These tables are essential for tracking the status and results of your imports.","That's it! Laravel Ingest is now installed and ready to be configured."]}],[{"l":"Your First Importer","p":["Let's create a simple importer to understand the core concepts of Laravel Ingest. We will build an importer for a User model."]},{"l":"1. Define the Importer Class","p":["An importer is a simple PHP class that implements the IngestDefinition interface. This interface has a single method, getConfig(), which returns an IngestConfig object. This object declaratively defines the entire import process.","Create a new file at app/Ingest/UserImporter.php:","This configuration tells Laravel Ingest to:","Import data into the User model.","Expect a file UPLOAD as the source.","Use the email column to identify unique records.","If a user with the same email already exists, UPDATE their record.","Map the CSV column full_name to the name attribute on the model.","Map user_email to email.","Map is_admin to is_admin, transforming the value \"yes\" into a boolean.","Validate the incoming data using the provided rules."]},{"l":"2. Register the Importer","p":["To make your importer discoverable by the framework, you need to \"tag\" it in a service provider. The AppServiceProvider is a great place for this.","Laravel Ingest automatically generates a URL-friendly \"slug\" from the class name. UserImporter becomes user-importer."]},{"l":"3. Run the Import","p":["Your importer is now ready! You can trigger it via the built-in API or the command line. Prepare a CSV file named users.csv:"]},{"l":"Via API","p":["Send a multipart/form-data POST request to the auto-generated endpoint:"]},{"l":"Via CLI","p":["If your file is on a disk accessible by the application, you can use the Artisan command:","The import will be queued and processed in the background. You can now monitor its progress."]}],[{"l":"The IngestConfig Class","p":["The IngestConfig object is the declarative heart of your importer. It allows you to define the entire ETL (Extract, Transform, Load) process in a fluent, readable way.","All configuration happens inside the getConfig() method of your importer class."]},{"l":"Basic Setup"},{"l":"for(string $modelClass)","p":["Required. Initializes the configuration for a specific Eloquent model. This must be the static entry point."]},{"l":"fromSource(SourceType $type, array $options = [])","p":["Required. Defines where the data comes from.","$type: An enum instance of LaravelIngest\\Enums\\SourceType.","$options: An associative array of options required by the specific source handler (e.g., path, disk, url)."]},{"l":"Identity & Duplicates"},{"l":"keyedBy(string $sourceColumn)","p":["Defines the \"Unique ID\" column in your source file(not the database column name). This is used to check if a record already exists."]},{"l":"onDuplicate(DuplicateStrategy $strategy)","p":["Defines behavior when a record with the keyedBy value is found in the database.","DuplicateStrategy::SKIP: (Default) Do nothing. Keep the old record.","DuplicateStrategy::UPDATE: Overwrite the database record with new data.","DuplicateStrategy::FAIL: Stop processing this row and mark it as failed.","DuplicateStrategy::UPDATE_IF_NEWER: Only update if the source data is newer (requires compareTimestamp())."]},{"l":"compareTimestamp(string $sourceColumn, string $dbColumn = 'updated_at')","p":["Used with DuplicateStrategy::UPDATE_IF_NEWER. Compares a timestamp from the source data with a database column to determine if the record should be updated."]},{"l":"Mapping & Transformation"},{"l":"map(string|array $sourceColumn, string $modelAttribute)","p":["A 1:1 copy from source to database. Supports column aliases for files with varying headers."]},{"l":"mapAndTransform(string|array $sourceColumn, string $modelAttribute, callable $callback)","p":["Transforms the value before saving. Also supports column aliases.","Callback Signature: fn($value, array $row)","$value: The value of the specific column.","$row: The entire raw row array (useful for combining columns)."]},{"l":"relate(string $sourceColumn, string $relationName, string $relatedModel, string $relatedKey, bool $createIfMissing = false)","p":["Automatically resolves BelongsTo relationships.","Takes the value from $sourceColumn.","Searches $relatedModel where $relatedKey matches that value.","If found, assigns the ID to the foreign key of $relationName.","If createIfMissing is true and no match is found, creates the related record automatically."]},{"l":"relateMany(string $sourceField, string $relationName, string $relatedModel, string $relatedKey = 'id', string $separator = ',')","p":["Automatically resolves BelongsToMany relationships. Parses a delimited string from the source and syncs the pivot table."]},{"l":"Validation"},{"l":"validate(array $rules)","p":["Applies Laravel validation rules to the incoming data before it is transformed or saved. Keys must match the source file columns."]},{"l":"validateWithModelRules()","p":["Merges validation rules defined in the target model's static getRules() method. Useful for DRY (Don't Repeat Yourself). Rules from validate() take precedence over model rules."]},{"l":"Hooks"},{"l":"beforeRow(callable $callback)","p":["Executed before validation. Allows you to modify the raw data array by reference. Perfect for cleaning up messy data globally."]},{"l":"afterRow(callable $callback)","p":["Executed after the model has been successfully saved.","$model: The saved Eloquent model.","$row: The original raw data."]},{"l":"Processing Options"},{"l":"setChunkSize(int $size)","p":["Determines how many rows are processed per background job. Default: 100.","Increase for simple inserts to reduce queue overhead.","Decrease for memory-heavy operations (e.g., image processing in afterRow)."]},{"l":"atomic()","p":["Wraps each chunk in a Database Transaction. If one row in the chunk fails, all rows in that chunk are rolled back.","Default: Disabled (Rows are committed individually)."]},{"l":"setDisk(string $disk)","p":["Overrides the default filesystem disk (from config/ingest.php) for this specific importer."]},{"l":"strictHeaders(bool $strict = true)","p":["Enables strict header validation. When enabled, the import will fail immediately if any mapped source column is missing from the file headers. By default, only the keyedBy column is validated."]},{"l":"Dynamic Model Resolution"},{"l":"resolveModelUsing(callable $callback)","p":["Allows you to dynamically determine which Eloquent model to use based on the row data. This is useful when importing heterogeneous data into different tables.","Callback Signature: fn(array $rowData): string","Returns: A fully qualified model class name.","Note: The base model class passed to IngestConfig::for() is used as a fallback if no resolver is set."]},{"l":"Transaction Modes"},{"l":"transactionMode(TransactionMode $mode)","p":["Fine-grained control over database transaction behavior.","TransactionMode::NONE: No transactions (default). Each row is committed individually.","TransactionMode::CHUNK: Wraps each chunk in a transaction. Same as calling atomic().","TransactionMode::ROW: Wraps each individual row in its own transaction."]}],[{"l":"Available Source Types","p":["Laravel Ingest is designed to be source-agnostic. You define the source of your data using the fromSource() method on your IngestConfig object. Here are the built-in source handlers and their required options."]},{"l":"SourceType::UPLOAD","p":["This is the most common source type for user-facing imports. It expects a file to be provided via an API request.","Payload: An instance of Illuminate\\Http\\UploadedFile.","Options: No options are required in the IngestConfig."]},{"l":"SourceType::FILESYSTEM","p":["This handler reads a file directly from one of your configured Laravel filesystem disks (e.g., local, s3). It's ideal for imports triggered by console commands or scheduled jobs.","Payload: The path to the file can be passed as a string payload to the Ingest::start() method (or via CLI --file argument).","Options:","path(string): The default path to the file if no payload is provided.","disk(string, optional): Overrides the default disk for this specific import."]},{"l":"SourceType::URL","p":["This handler downloads a file from a public URL and processes it. The file is streamed to a temporary local file to keep memory usage low.","Payload: None. The URL is configured directly.","Options:","url(string): The full URL to the file to be downloaded."]},{"l":"SourceType::FTP & SourceType::SFTP","p":["These handlers use the RemoteDiskHandler to download a file from a remote server configured as a Laravel filesystem disk. This requires a corresponding disk configuration in config/filesystems.php.","Payload: None.","Options:","disk(string): Required. The name of the FTP/SFTP disk configured in config/filesystems.php.","path(string): Required. The path to the file on the remote server."]},{"l":"Example Filesystem Configuration","p":["First, configure your disk in config/filesystems.php:","Note: FTP support requires league/flysystem-ftp. SFTP support requires league/flysystem-sftp-v3. Install via:"]},{"l":"Example IngestConfig","p":["Then, use the configured disk in your importer:"]},{"l":"Custom Source Handlers","p":["You can create your own source handlers for custom data sources (APIs, XML, etc.). See the Custom Source Handlers guide for details."]}],[{"l":"Monitoring, Cancellation, and Retries","p":["After starting an import, you can monitor its progress, cancel it if necessary, or retry any failed rows. These actions can be performed via Artisan commands or the API."]},{"l":"Monitoring Status","p":["Each import process creates an IngestRun record in the database. You can query this record to get detailed information about the status and progress of the import."]},{"l":"Via Artisan Command","p":["Use the ingest:status command with the run ID.","This will display a detailed summary, including status, progress counts, and a progress bar for running imports. If the run failed, it will also display the error message."]},{"l":"Via API","p":["Make a GET request to the show endpoint.","Endpoint: GET /api/v1/ingest/{ingestRun}","The response will be a JSON object containing the full IngestRun details, including a list of all processed rows if the run is configured to log them."]},{"l":"Cancelling an Ingest Run","p":["You can request to cancel a batch that is currently processing. This is useful if you start a large import by mistake.","Note: Cancellation sends a signal to the Laravel Queue batch. It may take a moment for currently processing jobs to finish before the batch is marked as cancelled."]},{"i":"via-artisan-command-1","l":"Via Artisan Command"},{"i":"via-api-1","l":"Via API","p":["Endpoint: POST /api/v1/ingest/{ingestRun}/cancel"]},{"l":"Retrying Failed Rows","p":["If an import completes with failed rows, you don't need to re-upload the entire file. You can create a new import run that consists only of the rows that failed in the original run."]},{"i":"via-artisan-command-2","l":"Via Artisan Command","p":["Use the ingest:retry command with the ID of the original failed run.","This will create a new IngestRun and queue the jobs. You will get a new run ID to monitor."]},{"i":"via-api-2","l":"Via API","p":["Endpoint: POST /api/v1/ingest/{ingestRun}/retry","The response will be the JSON representation of the new ingest run that has been created."]},{"l":"Analyzing Errors","p":["For runs with failed rows, you can get an aggregated error summary to quickly identify the most common issues."]},{"i":"via-api-3","l":"Via API","p":["Endpoint: GET /api/v1/ingest/{ingestRun}/errors/summary","The response groups errors by type and shows their frequency:"]}],[{"l":"Running Imports","p":["Once an importer is defined and registered, you can start an import process in several ways, depending on your use case."]},{"l":"1. Via Artisan Command","p":["The ingest:run command is perfect for manual or scheduled imports where the source file is accessible on a local or configured filesystem disk."]},{"l":"Command Signature","p":["slug: The slug of the importer you want to run (e.g., user-importer).","--file: (Optional) The path to the source file. This is required for FILESYSTEM sources and will be passed as the payload.","--dry-run: (Optional) Simulates the entire import process—including validation and transformation—without saving any data to the database. This is extremely useful for testing a new file."]},{"l":"Example"},{"l":"2. Via API","p":["Laravel Ingest automatically registers API endpoints to trigger and manage imports. These are ideal for integrations or when providing a user interface for uploads."]},{"l":"File Uploads (UPLOAD source)","p":["To start an import that uses SourceType::UPLOAD, send a multipart/form-data POST request.","Endpoint: POST /api/v1/ingest/upload/{importerSlug}","Body: Must contain a file field with the uploaded file. You can also include an optional dry_run field set to 1 or true."]},{"l":"Triggering Other Sources (FTP, URL, etc.)","p":["For importers that don't require a file upload (like FTP or URL sources), you can trigger them with a simple POST request.","Endpoint: POST /api/v1/ingest/trigger/{importerSlug}"]},{"l":"3. Programmatically (Facade)","p":["You can start an import directly from your application code using the Ingest Facade. This is useful for complex workflows, scheduled jobs, or custom controllers."]}],[{"l":"Working with Events","p":["Laravel Ingest dispatches events at every stage of the import lifecycle. This allows you to decouple your logic: the importer handles the data, and your listeners handle notifications, logging, or cleanup."]},{"l":"Available Events","p":["$ingestRun","$ingestRun, $exception","$ingestRun, $results","$ingestRun, $status, $data, $model, $errors","A batch of rows finished.","A single row was handled.","All jobs finished successfully.","ChunkProcessed","Description","Event Class","IngestRunCompleted","IngestRunFailed","IngestRunStarted","Payload","RowProcessed","The import record is created.","The process crashed or stopped."]},{"l":"Tutorial: Sending a Slack Notification","p":["Let's implement a listener that sends a summary to Slack when an import completes."]},{"l":"1. Create the Notification"},{"l":"2. Create the Listener"},{"l":"3. Register the Listener","p":["In your EventServiceProvider:","Now, every time an import finishes, the user who started it gets a notification!"]}],[{"l":"Custom Source Handlers","p":["Sometimes CSVs aren't enough. You might need to import data from a JSON API, an XML feed, or a Google Sheet. You can add support for any data source by creating a custom Source Handler."]},{"l":"The Concept","p":["A Source Handler is responsible for one thing: Converting a raw source into a Generator of arrays.","Laravel Ingest doesn't care where the data comes from, as long as you yield it row by row. This ensures memory efficiency even for massive datasets."]},{"l":"The SourceHandler Interface","p":["Every handler must implement LaravelIngest\\Contracts\\SourceHandler:"]},{"l":"Tutorial: Building a JSON Array Handler","p":["Let's build a handler that accepts a raw JSON array string. This is useful for importing data directly from a frontend POST request body."]},{"l":"1. Implement the Interface","p":["Create app/Ingest/Handlers/JsonArrayHandler.php:"]},{"l":"2. Register the Handler","p":["Add it to config/ingest.php by mapping an existing SourceType enum value to your handler:"]},{"l":"3. Alternative: Direct Handler Injection","p":["For more flexibility, you can bypass the SourceType enum entirely by using the handler directly in your code:"]},{"l":"Example: API Response Handler","p":["Here's a more practical example that fetches data from an external API:"]}],[{"l":"UI Integration Guide","p":["Laravel Ingest provides a full REST API, making it easy to build rich, real-time import interfaces in React, Vue, or Livewire.","This guide outlines the standard flow for building an import UI."]},{"l":"The Workflow","p":["Upload: User selects a file. You POST it to the API.","Receive ID: The API returns an IngestRun object with an id and status processing.","Poll: You query the status endpoint every X seconds.","Finish: When status is completed(or failed), you stop polling and show the result."]},{"l":"Example: Vue.js Component","p":["Here is a simplified example using Vue 3 and Axios."]},{"l":"Handling Retries","p":["If run.status is completed_with_errors or failed, you can offer a \"Retry Failed Rows\" button."]}],[{"l":"API Reference","p":["Laravel Ingest exposes a RESTful API for managing and monitoring import processes. All endpoints are prefixed with /api/v1/ingest(configurable via config/ingest.php)."]},{"l":"Authentication","p":["The API routes are wrapped in the api middleware group by default. You will typically need to provide an authentication token (e.g., Sanctum or Passport) in the Authorization header."]},{"l":"List Ingest Runs","p":["Retrieves a paginated list of all ingest runs, sorted by the most recent.","Endpoint: GET /","Success Response: 200 OK with a paginated JSON object of IngestRunResource objects."]},{"l":"Show Ingest Run Details","p":["Retrieves the details of a single ingest run, including its rows.","Endpoint: GET /{ingestRun}","URL Parameters:","ingestRun(integer, required): The ID of the ingest run.","Success Response: 200 OK with a single IngestRunResource object."]},{"l":"Upload File and Start Run","p":["Starts a new ingest run from a file upload.","Endpoint: POST /upload/{importerSlug}","URL Parameters:","importerSlug(string, required): The slug of the importer definition (e.g., user-importer).","Body (multipart/form-data):","file(file, required): The data file to import (e.g., CSV, XLSX).","dry_run(boolean, optional): If 1 or true, performs a simulation without saving data.","Success Response: 202 Accepted with the newly created IngestRunResource."]},{"l":"Trigger Non-Upload Run","p":["Starts a new ingest run for a source that does not require a file upload (e.g., FTP, URL).","Endpoint: POST /trigger/{importerSlug}","URL Parameters:","importerSlug(string, required): The slug of the importer definition.","Success Response: 202 Accepted with the newly created IngestRunResource."]},{"l":"Cancel Ingest Run","p":["Sends a cancellation request to a running ingest batch.","Endpoint: POST /{ingestRun}/cancel","URL Parameters:","ingestRun(integer, required): The ID of the ingest run to cancel.","Success Response: 200 OK with {message: Cancellation request sent.}."]},{"l":"Retry Failed Ingest Run","p":["Creates a new ingest run containing only the failed rows from a previous run.","Endpoint: POST /{ingestRun}/retry","URL Parameters:","ingestRun(integer, required): The ID of the original run with failed rows.","Body (application/json, optional):","{dry_run: true}","Success Response: 202 Accepted with the newly created retry IngestRunResource.","Error Response: 400 Bad Request if the original run has no failed rows."]},{"l":"Get Error Summary","p":["Retrieves an aggregated summary of errors for a specific ingest run. Useful for quickly understanding the most common issues without fetching all failed rows.","Endpoint: GET /{ingestRun}/errors/summary","URL Parameters:","ingestRun(integer, required): The ID of the ingest run.","Success Response: 200 OK with an IngestErrorSummaryResource object."]},{"l":"Download Failed Rows as CSV","p":["Downloads a CSV file containing only the failed rows from an ingest run. The CSV includes all original data columns plus _error_message and _row_number columns. This enables a \"Fix & Re-Upload\" workflow.","Endpoint: GET /{ingestRun}/failed-rows/download","URL Parameters:","ingestRun(integer, required): The ID of the ingest run.","Success Response: 200 OK with a streamed CSV file download.","Error Response: 404 Not Found if the run has no failed rows."]},{"l":"IngestErrorSummaryResource Object","p":["The JSON representation for an error analysis summary."]},{"l":"IngestRunResource Object","p":["The standard JSON representation for an ingest run."]}]]