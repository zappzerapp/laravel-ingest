[[{"l":"Introduction to Laravel Ingest","p":["Stop writing spaghetti code for imports.","Laravel Ingest is a robust, configuration-driven ETL (Extract, Transform, Load) framework for Laravel. It replaces fragile, procedural import scripts with elegant, declarative configuration classes.","The system handles the \"dirty\" work—file processing, streaming, validation, background jobs, error reporting, and API provision—so you can focus on the business logic."]},{"l":"The Core Problem We Solve","p":["Importing data (CSV, Excel, etc.) is often a painful process: repetitive code, lack of robustness with large files, poor user experience, and inadequate error handling. Laravel Ingest solves this with a declarative, configuration-driven approach."]},{"l":"Key Features","p":["♾️ Infinite Scalability: Uses Generators and Queues to process files of any size with flat memory usage.","\uD83D\uDCDD Declarative Syntax: Define what to import, not how to loop over it, using a fluent IngestConfig class.","\uD83E\uDDEA Dry Runs: Simulate imports to find validation errors without touching the database.","\uD83D\uDD17 Auto-Relations: Automatically resolves BelongsTo and BelongsToMany relationships (e.g., finding IDs by names).","\uD83D\uDEE1️ Robust Error Handling: Tracks every failed row and allows you to download a CSV of only the failures to fix and retry.","\uD83D\uDD0C API & CLI Ready: Comes with auto-generated API endpoints and Artisan commands for full control.","\uD83D\uDDFA️ Source Agnostic: Import from file uploads, (S)FTP servers, URLs, or any Laravel filesystem disk ( s3, local).","\uD83C\uDFAD Column Aliases: Support multiple header names for the same field (e.g., ['email', 'E-Mail', 'user_email']).","\uD83D\uDE80 Dynamic Model Resolution: Route rows to different Eloquent models based on row data."]}],[{"l":"Installation","p":["Getting started with Laravel Ingest is simple. Follow these steps to integrate the package into your project."]},{"l":"1. Require with Composer","p":["First, add the package to your project's dependencies using Composer:"]},{"l":"2. Publish Assets","p":["Next, publish the configuration file and database migrations. This will create config/ingest.php and the necessary migration files in database/migrations/.","You can choose to publish only the configuration or the migrations by using the tags ingest-config or ingest-migrations."]},{"l":"3. Run Migrations","p":["Run the database migrations to create the ingest_runs and ingest_rows tables. These tables are essential for tracking the status and results of your imports.","That's it! Laravel Ingest is now installed and ready to be configured."]}],[{"l":"Your First Importer","p":["Let's create a simple importer to understand the core concepts of Laravel Ingest. We will build an importer for a User model."]},{"l":"1. Define the Importer Class","p":["An importer is a simple PHP class that implements the IngestDefinition interface. This interface has a single method, getConfig(), which returns an IngestConfig object. This object declaratively defines the entire import process.","Create a new file at app/Ingest/UserImporter.php:","This configuration tells Laravel Ingest to:","Import data into the User model.","Expect a file UPLOAD as the source.","Use the email column to identify unique records.","If a user with the same email already exists, UPDATE their record.","Map the CSV column full_name to the name attribute on the model.","Map user_email to email.","Map is_admin to is_admin, transforming the value \"yes\" into a boolean.","Validate the incoming data using the provided rules."]},{"l":"2. Register the Importer","p":["To make your importer discoverable by the framework, you need to \"tag\" it in a service provider. The AppServiceProvider is a great place for this.","Laravel Ingest automatically generates a URL-friendly \"slug\" from the class name. UserImporter becomes user-importer."]},{"l":"3. Run the Import","p":["Your importer is now ready! You can trigger it via the built-in API or the command line. Prepare a CSV file named users.csv:"]},{"l":"Via API","p":["Send a multipart/form-data POST request to the auto-generated endpoint:"]},{"l":"Via CLI","p":["If your file is on a disk accessible by the application, you can use the Artisan command:","The import will be queued and processed in the background. You can now monitor its progress."]}],[{"l":"Configuration","p":["This section covers all aspects of configuring Laravel Ingest, from basic setup to advanced security considerations."]},{"l":"Security Best Practices","p":["When dealing with file uploads and data imports, security should be a top priority. Here are the recommended security configurations for production environments."]},{"l":"File Upload Security"},{"l":"1. Restrict File Types"},{"l":"2. File Size Limits"},{"l":"3. Virus Scanning (Optional but Recommended)"},{"l":"Data Validation Security"},{"l":"1. Input Sanitization"},{"l":"2. SQL Injection Prevention"},{"l":"3. Data Type Validation"},{"l":"Access Control"},{"l":"1. Permission-Based Import Access"},{"l":"2. Rate Limiting"},{"l":"3. Audit Logging"},{"l":"Environment-Specific Security"},{"l":"1. Production Configuration"},{"l":"2. Development Configuration"},{"l":"3. Staging Configuration"},{"l":"Data Privacy and Compliance"},{"l":"1. GDPR Considerations"},{"l":"2. Data Retention Policies"},{"l":"Security Headers and CORS"},{"l":"Monitoring and Alerting"},{"l":"1. Security Event Monitoring"},{"l":"2. Performance Monitoring"},{"l":"Security Checklist","p":["File type restrictions configured","File size limits enforced","Input validation and sanitization implemented","SQL injection prevention measures in place","Access control and permissions configured","Rate limiting applied to import endpoints","Comprehensive audit logging enabled","Environment-specific security configurations","Data privacy and compliance measures implemented","Security headers and CORS properly configured","Monitoring and alerting systems active","Regular security reviews and penetration testing"]},{"l":"Recommended Security Packages","p":["Remember: Security is an ongoing process, not a one-time configuration. Regularly review and update your security measures to protect against new threats."]}],[{"l":"The IngestConfig Class","p":["The IngestConfig object is the declarative heart of your importer. It allows you to define the entire ETL (Extract, Transform, Load) process in a fluent, readable way.","All configuration happens inside the getConfig() method of your importer class."]},{"l":"Basic Setup"},{"l":"for(string $modelClass)","p":["Required. Initializes the configuration for a specific Eloquent model. This must be the static entry point."]},{"l":"fromSource(SourceType $type, array $options = [])","p":["Required. Defines where the data comes from.","$type: An enum instance of LaravelIngest\\Enums\\SourceType.","$options: An associative array of options required by the specific source handler (e.g., path, disk, url)."]},{"l":"Identity & Duplicates"},{"l":"keyedBy(string $sourceColumn)","p":["Defines the \"Unique ID\" column in your source file(not the database column name). This is used to check if a record already exists."]},{"l":"onDuplicate(DuplicateStrategy $strategy)","p":["Defines behavior when a record with the keyedBy value is found in the database.","DuplicateStrategy::SKIP: (Default) Do nothing. Keep the old record.","DuplicateStrategy::UPDATE: Overwrite the database record with new data.","DuplicateStrategy::FAIL: Stop processing this row and mark it as failed.","DuplicateStrategy::UPDATE_IF_NEWER: Only update if the source data is newer (requires compareTimestamp())."]},{"l":"compareTimestamp(string $sourceColumn, string $dbColumn = 'updated_at')","p":["Used with DuplicateStrategy::UPDATE_IF_NEWER. Compares a timestamp from the source data with a database column to determine if the record should be updated."]},{"l":"Mapping & Transformation"},{"l":"map(string|array $sourceColumn, string $modelAttribute)","p":["A 1:1 copy from source to database. Supports column aliases for files with varying headers."]},{"l":"mapAndTransform(string|array $sourceColumn, string $modelAttribute, callable $callback)","p":["Transforms the value before saving. Also supports column aliases.","Callback Signature: fn($value, array $row)","$value: The value of the specific column.","$row: The entire raw row array (useful for combining columns)."]},{"l":"relate(string $sourceColumn, string $relationName, string $relatedModel, string $relatedKey, bool $createIfMissing = false)","p":["Automatically resolves BelongsTo relationships.","Takes the value from $sourceColumn.","Searches $relatedModel where $relatedKey matches that value.","If found, assigns the ID to the foreign key of $relationName.","If createIfMissing is true and no match is found, creates the related record automatically."]},{"l":"relateMany(string $sourceField, string $relationName, string $relatedModel, string $relatedKey = 'id', string $separator = ',')","p":["Synchronizes Many-to-Many relationships from a delimited list in your source data. Perfect for tags, categories, or any pivot table relationship.","Parameters:","$sourceField: Column name in your source file containing the delimited values","$relationName: Name of the BelongsToMany relationship in your model","$relatedModel: The related Eloquent model class","$relatedKey: Attribute to search for in the related model (default: 'id')","$separator: Character used to split values (default: ',')","Behavior:","Duplicates in the source list are automatically handled","Non-existing related records will cause the row to fail (unless you handle them in beforeRow())","The entire pivot table for the relationship is synced (existing relationships not in the list will be removed)"]},{"l":"validateWithModelRules()","p":["Merges validation rules defined in the target model's static getRules() method. Useful for DRY (Don't Repeat Yourself). Rules from validate() take precedence over model rules."]},{"l":"Hooks"},{"l":"beforeRow(callable $callback)","p":["Executed before validation. Allows you to modify the raw data array by reference. Perfect for cleaning up messy data globally."]},{"l":"afterRow(callable $callback)","p":["Executed after the model has been successfully saved.","$model: The saved Eloquent model.","$row: The original raw data."]},{"l":"Processing Options"},{"l":"setChunkSize(int $size)","p":["Determines how many rows are processed per background job. Default: 100.","Increase for simple inserts to reduce queue overhead.","Decrease for memory-heavy operations (e.g., image processing in afterRow)."]},{"l":"atomic()","p":["Wraps each chunk in a Database Transaction. If one row in the chunk fails, all rows in that chunk are rolled back.","Default: Disabled (Rows are committed individually)."]},{"l":"setDisk(string $disk)","p":["Overrides the default filesystem disk (from config/ingest.php) for this specific importer."]},{"l":"strictHeaders(bool $strict = true)","p":["Enables strict header validation. When enabled, the import will fail immediately if any mapped source column is missing from the file headers. By default, only the keyedBy column is validated."]},{"l":"Dynamic Model Resolution"},{"l":"resolveModelUsing(callable $callback)","p":["Allows you to dynamically determine which Eloquent model to use based on the row data. This is useful when importing heterogeneous data into different tables.","Callback Signature: fn(array $rowData): string","Returns: A fully qualified model class name.","Note: The base model class passed to IngestConfig::for() is used as a fallback if no resolver is set."]},{"l":"Transaction Modes"},{"l":"transactionMode(TransactionMode $mode)","p":["Fine-grained control over database transaction behavior.","TransactionMode::NONE: No transactions (default). Each row is committed individually.","TransactionMode::CHUNK: Wraps each chunk in a transaction. Same as calling atomic().","TransactionMode::ROW: Wraps each individual row in its own transaction."]},{"l":"Composite Keys (geplant für v0.5)","p":["Aktuell unterstützt keyedBy() nur einfache Schlüssel. Für zusammengesetzte Schlüssel (z.B. ['store_id', 'sku']) können Sie Workarounds verwenden:"]},{"l":"Workaround 1: Künstliche Unique-Spalte erstellen","p":["Erstellen Sie eine kombinierte Spalte in Ihrer Quelldatei:","Beispiel CSV-Transformation:"]},{"l":"Workaround 2: Transformation in beforeRow()","p":["Verwenden Sie die beforeRow() Methode, um einen kombinierten Schlüssel zur Laufzeit zu erstellen:"]},{"l":"Workaround 3: Daten vor dem Import vorverarbeiten","p":["Für komplexe Szenarien können Sie die Daten vor dem Import in einem separaten Prozess vorbereiten:","Hinweis: Echte Composite-Key-Unterstützung ist für Version 0.5 geplant und wird diese Workarounds überflüssig machen."]}],[{"l":"Configuration Files","p":["Laravel Ingest provides two configuration files that control the behavior of the package. After installation, publish them with:"]},{"l":"ingest.php","p":["The main configuration file for Laravel Ingest."]},{"l":"Full Reference"},{"l":"Environment Variables","p":["Variable","Default","Description","INGEST_MAX_SHOW_ROWS","100","Max rows returned in API responses","INGEST_QUEUE_CONNECTION","QUEUE_CONNECTION","Queue connection for import jobs","INGEST_QUEUE_NAME","imports","Queue name for import jobs","INGEST_DISK","local","Default storage disk"]},{"l":"ingest_security.php","p":["Security-related configuration to protect against malicious uploads and requests."]},{"i":"full-reference-1","l":"Full Reference"},{"i":"environment-variables-1","l":"Environment Variables","p":["''","15","5","52428800(50MB)","Comma-separated allowlist of URL hosts","Comma-separated blocklist of URL hosts","Default","Description","INGEST_ALLOWED_URL_HOSTS","INGEST_BLOCKED_URL_HOSTS","INGEST_MAX_FILE_SIZE","INGEST_URL_MAX_REDIRECTS","INGEST_URL_TIMEOUT","Maximum HTTP redirects to follow","Maximum upload file size in bytes","null","URL request timeout in seconds","Variable"]},{"l":"Security Best Practices","p":["Always set middleware authentication in ingest.php:","Use URL host restrictions in production:","Restrict allowed directories to only what's needed:","Set appropriate file size limits based on your needs:"]}],[{"l":"Enums Reference","p":["Laravel Ingest uses several PHP 8.1+ enums for type-safe configuration. This page documents all available enums and their values."]},{"l":"IngestStatus","p":["'completed_with_errors'","'completed'","'failed'","'pending'","'processing'","All rows processed successfully","COMPLETED","COMPLETED_WITH_ERRORS","Currently processing rows","Description","FAILED","Finished but some rows failed","Import failed completely","Namespace: LaravelIngest\\Enums\\IngestStatus","PENDING","PROCESSING","Represents the current state of an import run.","Run created but not yet processing","String","Value"]},{"l":"Usage Examples"},{"l":"Status Flow"},{"l":"SourceType","p":["'filesystem'","'ftp'","'json-stream'","'sftp'","'upload'","'url'","Defines where import data comes from.","Description","FILESYSTEM","FTP","FTP server","HTTP file upload","JSON","JSON file with memory-efficient streaming","Local or cloud filesystem (S3, etc.)","Namespace: LaravelIngest\\Enums\\SourceType","Remote URL (HTTP/HTTPS)","SFTP","SFTP server","String","UPLOAD","URL","Value"]},{"i":"usage-examples-1","l":"Usage Examples"},{"l":"DuplicateStrategy","p":["'fail'","'skip'","'update_if_newer'","'update'","Defines behavior when a record with matching keyedBy value already exists.","Description","FAIL","Keep existing record, don't update (default)","Mark row as failed, don't modify existing","Namespace: LaravelIngest\\Enums\\DuplicateStrategy","Overwrite existing record with new data","SKIP","String","UPDATE","Update only if source is newer (requires compareTimestamp())","UPDATE_IF_NEWER","Value"]},{"i":"usage-examples-2","l":"Usage Examples"},{"l":"Decision Guide","p":["Scenario","Recommended Strategy","Daily full product catalog sync","UPDATE","Importing new user registrations","SKIP","Financial transactions (no duplicates allowed)","FAIL","Incremental updates from CMS","UPDATE_IF_NEWER"]},{"l":"TransactionMode","p":["Controls database transaction behavior during import.","Namespace: LaravelIngest\\Enums\\TransactionMode","Value","String","Description","NONE","'none'","No transactions, each row committed individually (default)","CHUNK","'chunk'","Wrap each chunk in a transaction","ROW","'row'","Wrap each individual row in a transaction"]},{"i":"usage-examples-3","l":"Usage Examples"},{"l":"Performance vs. Consistency Trade-offs","p":["CHUNK","Chunk-level consistency","Complex operations with side effects","Data Consistency","Fastest","Logs, non-critical data","Medium","Mode","Most imports","NONE","Partial imports possible","ROW","Row-level consistency","Slowest","Speed","Use Case"]},{"l":"Using Enums in Queries","p":["All enums are backed by string values, making them easy to use in database queries:"]},{"l":"Type Hints","p":["Use enums in your own code for type safety:"]}],[{"l":"Available Source Types","p":["Laravel Ingest is designed to be source-agnostic. You define the source of your data using the fromSource() method on your IngestConfig object. Here are the built-in source handlers and their required options."]},{"l":"SourceType::UPLOAD","p":["This is the most common source type for user-facing imports. It expects a file to be provided via an API request.","Payload: An instance of Illuminate\\Http\\UploadedFile.","Options: No options are required in the IngestConfig."]},{"l":"SourceType::FILESYSTEM","p":["This handler reads a file directly from one of your configured Laravel filesystem disks (e.g., local, s3). It's ideal for imports triggered by console commands or scheduled jobs.","Payload: The path to the file can be passed as a string payload to the Ingest::start() method (or via CLI --file argument).","Options:","path(string): The default path to the file if no payload is provided.","disk(string, optional): Overrides the default disk for this specific import."]},{"l":"SourceType::URL","p":["This handler downloads a file from a public URL and processes it. The file is streamed to a temporary local file to keep memory usage low.","Payload: None. The URL is configured directly.","Options:","url(string): The full URL to the file to be downloaded."]},{"l":"SourceType::JSON","p":["This handler processes a file containing a JSON array of objects. It's useful for API-driven imports or when dealing with structured data feeds.","Payload: The full path to the JSON file.","Options: No options are required."]},{"l":"Example IngestConfig"},{"l":"Example Usage"},{"l":"Example users.json File","p":["The file must contain a single top-level array. Each element in the array is treated as a row."]},{"l":"SourceType::FTP & SourceType::SFTP","p":["These handlers use the RemoteDiskHandler to download a file from a remote server configured as a Laravel filesystem disk. This requires a corresponding disk configuration in config/filesystems.php.","Payload: None.","Options:","disk(string): Required. The name of the FTP/SFTP disk configured in config/filesystems.php.","path(string): Required. The path to the file on the remote server."]},{"l":"Example Filesystem Configuration","p":["First, configure your disk in config/filesystems.php:","Note: FTP support requires league/flysystem-ftp. SFTP support requires league/flysystem-sftp-v3. Install via:"]},{"i":"example-ingestconfig-1","l":"Example IngestConfig","p":["Then, use the configured disk in your importer:"]},{"l":"Custom Source Handlers","p":["You can create your own source handlers for custom data sources (APIs, XML, etc.). See the Custom Source Handlers guide for details."]}],[{"l":"Facade Reference","p":["The Ingest Facade provides a convenient interface to interact with the IngestManager. Use it to programmatically start imports, retry failed runs, and access importer definitions."]},{"l":"Methods"},{"l":"start()","p":["?Authenticatable","$importer","$isDryRun","$payload","$user","bool","DefinitionNotFoundException- If importer slug is not registered","Description","FileProcessingException- If file validation fails","If true, validate and transform without persisting","InvalidConfigurationException- If importer config is invalid","mixed","Parameter","Returns: IngestRun- The Eloquent model for the newly created run.","Source data: file path, UploadedFile, URL, or null","SourceException- If source cannot be read","Start a new import run.","string","The registered slug of the importer","Throws:","Type","User to associate with the run (for auditing)"]},{"l":"Examples"},{"l":"retry()","p":["?Authenticatable","$isDryRun","$originalRun","$user","bool","ConcurrencyException- If a retry is already in progress","DefinitionNotFoundException- If importer no longer exists","Description","If true, validate without persisting","IngestRun","NoFailedRowsException- If the original run has no failed rows","Parameter","Retry failed rows from a previous import run.","Returns: IngestRun- A new IngestRun for the retry attempt.","The original run with failed rows","Throws:","Type","User to associate with the retry run"]},{"i":"examples-1","l":"Examples","p":["The retry run maintains a reference to the original:"]},{"l":"getDefinition()","p":["Get a specific importer definition by its slug.","Parameter","Type","Description","$slug","string","The registered slug of the importer","Returns: IngestDefinition- The importer class instance.","Throws:","DefinitionNotFoundException- If slug is not registered"]},{"i":"examples-2","l":"Examples"},{"l":"getDefinitions()","p":["Get all registered importer definitions.","Returns: array- Associative array of slug => IngestDefinition instances."]},{"i":"examples-3","l":"Examples"},{"l":"Common Patterns"},{"l":"Controller Integration"},{"l":"Scheduled Imports"},{"l":"Queued Job"},{"l":"Event-Driven Imports"}],[{"l":"Monitoring, Cancellation, and Retries","p":["After starting an import, you can monitor its progress, cancel it if necessary, or retry any failed rows. These actions can be performed via Artisan commands or the API."]},{"l":"Monitoring Status","p":["Each import process creates an IngestRun record in the database. You can query this record to get detailed information about the status and progress of the import."]},{"l":"Via Artisan Command","p":["Use the ingest:status command with the run ID.","This will display a detailed summary, including status, progress counts, and a progress bar for running imports. If the run failed, it will also display the error message."]},{"l":"Via API","p":["Make a GET request to the show endpoint.","Endpoint: GET /api/v1/ingest/{ingestRun}","The response will be a JSON object containing the full IngestRun details, including a list of all processed rows if the run is configured to log them."]},{"l":"Cancelling an Ingest Run","p":["You can request to cancel a batch that is currently processing. This is useful if you start a large import by mistake.","Note: Cancellation sends a signal to the Laravel Queue batch. It may take a moment for currently processing jobs to finish before the batch is marked as cancelled."]},{"i":"via-artisan-command-1","l":"Via Artisan Command"},{"i":"via-api-1","l":"Via API","p":["Endpoint: POST /api/v1/ingest/{ingestRun}/cancel"]},{"l":"Retrying Failed Rows","p":["If an import completes with failed rows, you don't need to re-upload the entire file. You can create a new import run that consists only of the rows that failed in the original run."]},{"i":"via-artisan-command-2","l":"Via Artisan Command","p":["Use the ingest:retry command with the ID of the original failed run.","This will create a new IngestRun and queue the jobs. You will get a new run ID to monitor."]},{"i":"via-api-2","l":"Via API","p":["Endpoint: POST /api/v1/ingest/{ingestRun}/retry","The response will be the JSON representation of the new ingest run that has been created."]},{"l":"Analyzing Errors","p":["For runs with failed rows, you can get an aggregated error summary to quickly identify the most common issues."]},{"i":"via-api-3","l":"Via API","p":["Endpoint: GET /api/v1/ingest/{ingestRun}/errors/summary","The response groups errors by type and shows their frequency:"]}],[{"l":"Running Imports","p":["Once an importer is defined and registered, you can start an import process in several ways, depending on your use case."]},{"l":"Artisan Commands","p":["Laravel Ingest provides several Artisan commands for managing imports."]},{"l":"ingest:run","p":["The ingest:run command is perfect for manual or scheduled imports where the source file is accessible on a local or configured filesystem disk.","Argument/Option","Description","slug","The slug of the importer to run (e.g., user-importer)","--file","Path to the source file (required for FILESYSTEM sources)","--dry-run","Simulate the import without saving data"]},{"l":"ingest:list","p":["List all registered importers and their configurations."]},{"l":"ingest:status","p":["Check the status of a specific import run.","Argument","Description","id","The ID of the IngestRun to check"]},{"l":"ingest:cancel","p":["Cancel a running import. This will stop processing new chunks but won't roll back already processed rows.","Argument","Description","id","The ID of the IngestRun to cancel"]},{"l":"ingest:retry","p":["Retry failed rows from a previous import run.","Argument/Option","Description","id","The ID of the IngestRun to retry","--dry-run","Simulate the retry without saving data"]},{"l":"ingest:prune-files","p":["Clean up old temporary and uploaded files to free disk space.","Option","Default","Description","--hours","24","Delete files older than this many hours","This command removes files from the ingest-temp and ingest-uploads directories that are older than the specified number of hours."]},{"l":"Scheduling File Cleanup","p":["Add to your routes/console.php or scheduler:"]},{"l":"Row Log Pruning","p":["To automatically prune old row logs (stored in ingest_rows table), add Laravel's model pruning command to your scheduler:","The retention period is configured via prune_days in config/ingest.php(default: 30 days)."]},{"l":"2. Via API","p":["Laravel Ingest automatically registers API endpoints to trigger and manage imports. These are ideal for integrations or when providing a user interface for uploads."]},{"l":"File Uploads (UPLOAD source)","p":["To start an import that uses SourceType::UPLOAD, send a multipart/form-data POST request.","Endpoint: POST /api/v1/ingest/upload/{importerSlug}","Body: Must contain a file field with the uploaded file. You can also include an optional dry_run field set to 1 or true."]},{"l":"Triggering Other Sources (FTP, URL, etc.)","p":["For importers that don't require a file upload (like FTP or URL sources), you can trigger them with a simple POST request.","Endpoint: POST /api/v1/ingest/trigger/{importerSlug}"]},{"l":"3. Programmatically (Facade)","p":["You can start an import directly from your application code using the Ingest Facade. This is useful for complex workflows, scheduled jobs, or custom controllers."]}],[{"l":"Advanced Topics","p":["This section covers advanced configuration, optimization techniques, and troubleshooting for Laravel Ingest."]},{"l":"Performance Optimization for Large Imports","p":["Choosing the right transaction mode and chunk size is crucial for performance when handling large datasets."]},{"l":"Transaction Mode Recommendations","p":["Scenario","Recommended Setting","Reasoning","100–10,000 rows","transactionMode(ROW)","Safety > Speed","10,000–100,000 rows","transactionMode(CHUNK)","Balance between safety and speed",">100,000 rows","transactionMode(NONE)","Speed > Safety","setChunkSize(1000)","Reduces queue overhead"]},{"l":"Chunk Size Optimization"},{"l":"Queue Worker Optimization"},{"l":"Database Optimization"},{"l":"Memory-Management"},{"l":"Strategies for Large Files","p":["Use URL sources instead of uploads for very large files","Reduce chunk size when encountering memory limit errors","Disable row logging for very large imports:"]},{"l":"PHP Configuration"},{"l":"Error Handling and Recovery"},{"l":"Retry Strategies"},{"l":"Error Thresholds"},{"l":"Monitoring and Debugging"},{"l":"Detailed Logging Strategy"},{"l":"Performance Metrics"},{"l":"Advanced Scenarios"},{"l":"Multi-Model Imports"},{"l":"Conditional Validation"},{"l":"External API Integration"}],[{"l":"Troubleshooting"},{"l":"1. \"File not found\" bei Filesystem-Quellen","p":["Fehlermeldung:","Ursachen:","Der Pfad ist relativ (z.B. imports/file.csv statt /absolute/path/file.csv).","Die Datei existiert nicht auf dem konfigurierten Disk.","Der Disk ist nicht korrekt in config/filesystems.php konfiguriert.","Lösungen:","Absolute Pfade verwenden:","Existenz prüfen:","Disk-Konfiguration prüfen:"]},{"l":"2. Memory-Limit Fehler","p":["Fehlermeldung:","Ursachen:","Die CSV/Excel-Datei ist zu groß für das aktuelle memory_limit in PHP.","Zu viele Zeilen werden gleichzeitig verarbeitet (z.B. chunkSize zu groß).","Lösungen:","memory_limit erhöhen(in php.ini):","Kleinere Chunks verwenden:","Transaktionen deaktivieren(für maximale Performance):","Queue-Worker optimieren:"]},{"l":"3. \"Column not found\" bei strictHeaders(true)","p":["Fehlermeldung:","Ursachen:","Die Spaltenüberschrift im CSV stimmt nicht mit der Definition in map() oder relate() überein.","Groß-/Kleinschreibung oder Leerzeichen unterscheiden sich (z.B. \"E-Mail\" vs. \"email\").","Lösungen:","Aliase verwenden:","strictHeaders(false) setzen(wenn die Spalte optional ist):","CSV-Datei anpassen(z.B. mit Excel oder sed):"]},{"l":"4. \"Connection timeout\" bei großen Uploads","p":["Fehlermeldung:","Ursachen:","Die Upload-Zeit überschreitet die PHP max_execution_time.","Der Webserver hat eine geringere Timeout-Einstellung.","Die Datei ist zu groß für den Upload.","Lösungen:","PHP-Konfiguration anpassen:","Webserver-Timeout erhöhen(nginx Beispiel):","Chunked Uploads im Frontend implementieren:"]},{"l":"5. \"Queue worker is not running\"","p":["Fehlermeldung:","Ursachen:","Der Queue-Worker läuft nicht.","Der Worker ist abgestürzt oder hat das Zeitlimit überschritten.","Queue-Konfiguration ist fehlerhaft.","Lösungen:","Worker starten und überwachen:","Supervisor-Konfiguration(/etc/supervisor/conf.d/laravel-worker.conf):","Queue-Status prüfen:"]},{"l":"6. \"Foreign key constraint violation\"","p":["Fehlermeldung:","Ursachen:","relate() oder relateMany() kann den referenzierten Datensatz nicht finden.","Die referenzierte ID existiert nicht in der Zieltabelle.","Die Beziehung ist falsch konfiguriert.","Lösungen:","Debug-Modus für Beziehungen aktivieren:","Datenvalidierung vor dem Import:","Fehlende Datensätze erstellen:"]},{"l":"7. \"Invalid datetime format\"","p":["Fehlermeldung:","Ursachen:","Das Datumsformat im CSV entspricht nicht dem erwarteten Format.","Leere oder ungültige Datumswerte.","Lösungen:","Datumstransformation implementieren:","Flexible Validierung:"]},{"l":"8. Performance ist sehr langsam","p":["Symptome:","Import von 10.000 Zeilen dauert mehrere Minuten.","Hohe CPU- und Speicher-Auslastung.","Ursachen:","Ineffiziente Datenbankabfragen in Hooks.","Zu kleine Chunk-Size.","Fehlende Indizes in der Datenbank.","Lösungen:","Chunk-Size optimieren:","Datenbank-Indizes prüfen:","Haken optimieren:","Transaktionen optimieren:"]},{"l":"9. Debugging-Techniken"},{"l":"Log-Dateien überprüfen","p":["Laravel Logs:","Queue Worker Logs:","Datenbank-Queries loggen:"]},{"l":"Test-Import mit kleinen Datenmengen","p":["Test-CSV erstellen:","Dry-Run durchführen:"]},{"l":"Schritt-für-Schritt-Debugging"},{"l":"10. Häufige Konfigurationsfehler"},{"l":"Falsche Source-Type-Konfiguration"},{"l":"Fehlende Berechtigungen"},{"l":"Queue-Konfiguration"},{"l":"Nächste Schritte bei Problemen","p":["Logs prüfen: Überprüfen Sie Laravel- und Worker-Logs","Konfiguration validieren: Stellen Sie sicher, dass alle Pfade und Berechtigungen korrekt sind","Mit kleinen Datenmengen testen: Isolieren Sie das Problem","Datenbank-Performance prüfen: Indizes und Query-Optimierung","Community-Support: Eröffnen Sie ein Issue auf GitHub mit detaillierten Informationen","Für weitere Hilfe besuchen Sie die Dokumentation oder erstellen Sie ein Issue im GitHub Repository."]}],[{"l":"Working with Events","p":["Laravel Ingest dispatches events at every stage of the import lifecycle. This allows you to decouple your logic: the importer handles the data, and your listeners handle notifications, logging, or cleanup."]},{"l":"Available Events","p":["$ingestRun","$ingestRun, $exception","$ingestRun, $results","$ingestRun, $status, $data, $model, $errors","A batch of rows finished.","A single row was handled.","All jobs finished successfully.","ChunkProcessed","Description","Event Class","IngestRunCompleted","IngestRunFailed","IngestRunStarted","Payload","RowProcessed","The import record is created.","The process crashed or stopped."]},{"l":"Tutorial: Sending a Slack Notification","p":["Let's implement a listener that sends a summary to Slack when an import completes."]},{"l":"1. Create the Notification"},{"l":"2. Create the Listener"},{"l":"3. Register the Listener","p":["In your EventServiceProvider:","Now, every time an import finishes, the user who started it gets a notification!"]}],[{"l":"Custom Source Handlers","p":["Sometimes CSVs aren't enough. You might need to import data from a JSON API, an XML feed, or a Google Sheet. You can add support for any data source by creating a custom Source Handler."]},{"l":"The Concept","p":["A Source Handler is responsible for one thing: Converting a raw source into a Generator of arrays.","Laravel Ingest doesn't care where the data comes from, as long as you yield it row by row. This ensures memory efficiency even for massive datasets."]},{"l":"The SourceHandler Interface","p":["Every handler must implement LaravelIngest\\Contracts\\SourceHandler:"]},{"l":"Tutorial: Building a JSON Array Handler","p":["Let's build a handler that accepts a raw JSON array string. This is useful for importing data directly from a frontend POST request body."]},{"l":"1. Implement the Interface","p":["Create app/Ingest/Handlers/JsonArrayHandler.php:"]},{"l":"2. Register the Handler","p":["Add it to config/ingest.php by mapping an existing SourceType enum value to your handler:"]},{"l":"3. Alternative: Direct Handler Injection","p":["For more flexibility, you can bypass the SourceType enum entirely by using the handler directly in your code:"]},{"l":"Example: API Response Handler","p":["Here's a more practical example that fetches data from an external API:"]}],[{"l":"UI Integration Guide","p":["Laravel Ingest provides a full REST API, making it easy to build rich, real-time import interfaces in React, Vue, or Livewire.","This guide outlines the standard flow for building an import UI."]},{"l":"The Workflow","p":["Upload: User selects a file. You POST it to the API.","Receive ID: The API returns an IngestRun object with an id and status processing.","Poll: You query the status endpoint every X seconds.","Finish: When status is completed(or failed), you stop polling and show the result."]},{"l":"Example: Vue.js Component","p":["Here is a simplified example using Vue 3 and Axios."]},{"l":"Handling Retries","p":["If run.status is completed_with_errors or failed, you can offer a \"Retry Failed Rows\" button."]},{"l":"Frontend Error Handling","p":["Robust error handling is crucial for a good user experience. Here are comprehensive strategies for handling different types of errors in your frontend."]},{"l":"Client-Side Validation","p":["Before uploading, validate files on the client side:"]},{"l":"Network Error Handling","p":["Handle network-related errors gracefully:"]},{"l":"API Error Response Handling","p":["Different HTTP status codes require different handling:"]},{"l":"Polling Error Handling","p":["Handle errors during status polling:"]},{"l":"Import Failure Handling","p":["Handle completed imports with errors:"]},{"l":"User-Friendly Error Display","p":["Create a comprehensive error display component:"]},{"l":"Accessibility Considerations","p":["Ensure your error handling is accessible:"]},{"l":"Best Practices Summary","p":["Validate early: Check files on the client side before uploading","Provide clear feedback: Show specific error messages and actionable suggestions","Handle network issues gracefully: Implement timeouts and retry logic","Be accessible: Use ARIA attributes and screen reader announcements","Log errors: Send error details to your monitoring service","Offer recovery options: Provide retry buttons and alternative actions","Don't overwhelm users: Show only relevant error details and suggestions"]}],[{"l":"Exceptions","p":["Laravel Ingest provides specific exception classes for different error scenarios. Understanding these exceptions helps you implement proper error handling in your application."]},{"l":"Exception Overview","p":["Exception","When Thrown","SourceException","Problems reading from data source","DefinitionNotFoundException","Importer slug not found","InvalidConfigurationException","Invalid IngestConfig setup","ConcurrencyException","Concurrent operation conflicts","NoFailedRowsException","Retry attempted with no failed rows","FileProcessingException","File validation or processing errors"]},{"l":"SourceException","p":["Thrown when there's a problem reading data from a source (file not found, connection failed, etc.).","Common causes:","File does not exist at specified path","FTP/SFTP connection or authentication failed","URL is unreachable or returned an error","Insufficient permissions to read file"]},{"l":"DefinitionNotFoundException","p":["Thrown when attempting to use an importer that hasn't been registered in config/ingest.php.","Solution: Ensure the importer is registered:"]},{"l":"InvalidConfigurationException","p":["Thrown when an IngestConfig is invalid or missing required settings.","Common causes:","Missing for() model class","Missing fromSource() definition","Invalid source type options","Incompatible configuration combinations"]},{"l":"ConcurrencyException","p":["Thrown when concurrent operations conflict with each other. Includes factory methods for specific scenarios."]},{"l":"Factory Methods","p":["Handling:"]},{"l":"NoFailedRowsException","p":["Thrown when attempting to retry an import run that has no failed rows.","Solution: Check for failed rows before retrying:"]},{"l":"FileProcessingException","p":["Thrown during file validation and processing. Includes factory methods for specific file-related errors."]},{"i":"factory-methods-1","l":"Factory Methods","p":["Handling upload errors:"]},{"l":"Global Exception Handling","p":["You can handle Ingest exceptions globally in your exception handler:"]},{"l":"Exception Inheritance","p":["All Ingest exceptions extend PHP's base Exception class:","This allows you to catch all Ingest exceptions with a single catch block if needed:"]}],[{"l":"API Reference","p":["Laravel Ingest exposes a RESTful API for managing and monitoring import processes. All endpoints are prefixed with /api/v1/ingest(configurable via config/ingest.php)."]},{"l":"Authentication","p":["The API routes are wrapped in the api middleware group by default. You will typically need to provide an authentication token (e.g., Sanctum or Passport) in the Authorization header."]},{"l":"List Ingest Runs","p":["Retrieves a paginated list of all ingest runs, sorted by the most recent.","Endpoint: GET /","Success Response: 200 OK with a paginated JSON object of IngestRunResource objects."]},{"l":"Show Ingest Run Details","p":["Retrieves the details of a single ingest run, including its rows.","Endpoint: GET /{ingestRun}","URL Parameters:","ingestRun(integer, required): The ID of the ingest run.","Success Response: 200 OK with a single IngestRunResource object."]},{"l":"Upload File and Start Run","p":["Starts a new ingest run from a file upload.","Endpoint: POST /upload/{importerSlug}","URL Parameters:","importerSlug(string, required): The slug of the importer definition (e.g., user-importer).","Body (multipart/form-data):","file(file, required): The data file to import (e.g., CSV, XLSX).","dry_run(boolean, optional): If 1 or true, performs a simulation without saving data.","Success Response: 202 Accepted with the newly created IngestRunResource."]},{"l":"Trigger Non-Upload Run","p":["Starts a new ingest run for a source that does not require a file upload (e.g., FTP, URL).","Endpoint: POST /trigger/{importerSlug}","URL Parameters:","importerSlug(string, required): The slug of the importer definition.","Success Response: 202 Accepted with the newly created IngestRunResource."]},{"l":"Cancel Ingest Run","p":["Sends a cancellation request to a running ingest batch.","Endpoint: POST /{ingestRun}/cancel","URL Parameters:","ingestRun(integer, required): The ID of the ingest run to cancel.","Success Response: 200 OK with {message: Cancellation request sent.}."]},{"l":"Retry Failed Ingest Run","p":["Creates a new ingest run containing only the failed rows from a previous run.","Endpoint: POST /{ingestRun}/retry","URL Parameters:","ingestRun(integer, required): The ID of the original run with failed rows.","Body (application/json, optional):","{dry_run: true}","Success Response: 202 Accepted with the newly created retry IngestRunResource.","Error Response: 400 Bad Request if the original run has no failed rows."]},{"l":"Get Error Summary","p":["Retrieves an aggregated summary of errors for a specific ingest run. Useful for quickly understanding the most common issues without fetching all failed rows.","Endpoint: GET /{ingestRun}/errors/summary","URL Parameters:","ingestRun(integer, required): The ID of the ingest run.","Success Response: 200 OK with an IngestErrorSummaryResource object."]},{"l":"Download Failed Rows as CSV","p":["Downloads a CSV file containing only the failed rows from an ingest run. The CSV includes all original data columns plus _error_message and _row_number columns. This enables a \"Fix & Re-Upload\" workflow.","Endpoint: GET /{ingestRun}/failed-rows/download","URL Parameters:","ingestRun(integer, required): The ID of the ingest run.","Success Response: 200 OK with a streamed CSV file download.","Error Response: 404 Not Found if the run has no failed rows."]},{"l":"IngestErrorSummaryResource Object","p":["The JSON representation for an error analysis summary."]},{"l":"IngestRunResource Object","p":["The standard JSON representation for an ingest run."]}]]